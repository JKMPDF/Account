const V={ASSET:["Current Assets","Bank Accounts","Cash-in-hand","Deposits (Asset)","Loans & Advances (Asset)","Stock-in-hand","Sundry Debtors","Fixed Assets","Investments","Suspense A/c"],LIABILITY:["Current Liabilities","Duties & Taxes","Provisions","Sundry Creditors","Bank OD A/c","Loans (Liability)","Secured Loans","Unsecured Loans"],EQUITY:["Capital Account","Reserves & Surplus"],INCOME:["Sales Accounts","Direct Incomes","Indirect Incomes"],EXPENSE:["Purchase Accounts","Direct Expenses","Indirect Expenses"]},S={LIABILITIES:{"Capital Account":["Capital Account"],"Loans (Liability)":["Loans (Liability)","Secured Loans","Unsecured Loans","Bank OD A/c"],"Current Liabilities":["Current Liabilities","Duties & Taxes","Provisions","Sundry Creditors"],"Reserves & Surplus":["Reserves & Surplus"]},ASSETS:{"Fixed Assets":["Fixed Assets"],Investments:["Investments"],"Current Assets":["Current Assets","Bank Accounts","Cash-in-hand","Deposits (Asset)","Loans & Advances (Asset)","Stock-in-hand","Sundry Debtors"],"Suspense A/c":["Suspense A/c"]}},D={INCOME:{"Revenue from Operations":["Sales Accounts","Direct Incomes"],"Other Income":["Indirect Incomes"]},EXPENSE:{"Cost of Materials Consumed":["Purchase Accounts"],"Other Expenses":["Direct Expenses","Indirect Expenses"]}},L=I=>{for(const h in V)if(V[h].includes(I))return h;return"UNKNOWN"},M=(I,h,E,g)=>{const f=new Map,u=new Map,p=new Map,r=new Date(E),c=new Date(g);return c.setHours(23,59,59,999),I.forEach(s=>{let e=0;if(s.openingBalance&&s.openingBalanceType){const n=Number(s.openingBalance)||0;e=s.openingBalanceType==="Dr"?n:-n}f.set(s.id,e)}),h.forEach(s=>{new Date(s.date)<r&&s.entries.forEach(e=>{const n=f.get(e.ledgerId)||0,o=Number(e.amount)||0,a=e.type==="Dr"?n+o:n-o;f.set(e.ledgerId,a)})}),h.forEach(s=>{const e=new Date(s.date);e>=r&&e<=c&&s.entries.forEach(n=>{const o=u.get(n.ledgerId)||0,a=Number(n.amount)||0,l=n.type==="Dr"?o+a:o-a;u.set(n.ledgerId,l)})}),I.forEach(s=>{const e=f.get(s.id)||0,n=u.get(s.id)||0;p.set(s.id,e+n)}),{openingBalances:f,transactions:u,closingBalances:p}},v=(I,h)=>{let E=0,g=0;const f=[],u=[];I.forEach(r=>{const c=L(r.group),s=h.get(r.id)||0;if(c==="INCOME"){const e=-s;e!==0&&(E+=e,f.push({name:r.name,balance:e}))}else c==="EXPENSE"&&s!==0&&(g+=s,u.push({name:r.name,balance:s}))});const p=E-g;return{incomeLedgers:f,expenseLedgers:u,totalIncome:E,totalExpense:g,netProfit:p}},B=(I,h,E,g)=>{const f=new Set(I.filter(t=>t.group==="Cash-in-hand"||t.group==="Bank Accounts"||t.group==="Bank OD A/c").map(t=>t.id)),u=new Map(I.map(t=>[t.id,t])),{openingBalances:p,closingBalances:r}=M(I,h,E,g);let c=0,s=0;for(const t of f)c+=p.get(t)||0,s+=r.get(t)||0;const e=new Date(E),n=new Date(g);n.setHours(23,59,59,999);const o=h.filter(t=>{const i=new Date(t.date);return i>=e&&i<=n}),a={total:0,activities:new Map},l={total:0,activities:new Map},d={total:0,activities:new Map};return o.forEach(t=>{const i=t.entries.find(y=>f.has(y.ledgerId));if(!i||t.entries.every(y=>f.has(y.ledgerId)))return;const C=i.type==="Dr"?i.amount:-i.amount;t.entries.forEach(y=>{if(f.has(y.ledgerId))return;const w=u.get(y.ledgerId);if(!w)return;let A;["Fixed Assets","Investments"].includes(w.group)?A=l.activities:["Capital Account","Loans (Liability)","Secured Loans","Unsecured Loans"].includes(w.group)?A=d.activities:A=a.activities;const Q=A.get(w.group)||0;A.set(w.group,Q+C)})}),a.total=Array.from(a.activities.values()).reduce((t,i)=>t+i,0),l.total=Array.from(l.activities.values()).reduce((t,i)=>t+i,0),d.total=Array.from(d.activities.values()).reduce((t,i)=>t+i,0),{operating:{total:a.total,activities:Array.from(a.activities.entries()).map(([t,i])=>({name:t,amount:i}))},investing:{total:l.total,activities:Array.from(l.activities.entries()).map(([t,i])=>({name:t,amount:i}))},financing:{total:d.total,activities:Array.from(d.activities.entries()).map(([t,i])=>({name:t,amount:i}))},openingBalance:c,closingBalance:s,netChange:s-c}},T=(I,h,E,g,f)=>{const u=new Map,p=new Date(g),r=new Date(f);r.setHours(23,59,59,999);const c=()=>({openingQty:0,openingValue:0,inwardQty:0,inwardValue:0,outwardQty:0,outwardValue:0,closingQty:0,closingValue:0});I.forEach(e=>{u.set(e.id,{total:c(),godowns:new Map})});const s=(e,n,o,a)=>{const l=u.get(e.stockItemId);if(!l)return;const d=e.godownId||"none";l.godowns.has(d)||l.godowns.set(d,c());const t=l.godowns.get(d),i=e.quantity*e.rate;let m="none";n==="Purchase"||n==="Credit Note"?m="inward":n==="Sale"||n==="Debit Note"?m="outward":n==="Stock Journal"&&(m=o==="Dr"?"inward":"outward"),m==="inward"?a?(t.openingQty+=e.quantity,t.openingValue+=i):(t.inwardQty+=e.quantity,t.inwardValue+=i):m==="outward"&&(a?(t.openingQty-=e.quantity,t.openingValue-=i):(t.outwardQty+=e.quantity,t.outwardValue+=i))};return h.forEach(e=>{const n=new Date(e.date),o=n<p,a=n>=p&&n<=r;!o&&!a||e.entries.forEach(l=>{var d;return(d=l.inventoryAllocations)==null?void 0:d.forEach(t=>s(t,e.type,l.type,o))})}),I.forEach(e=>{const n=u.get(e.id);if(n){n.godowns.forEach(t=>{t.closingQty=t.openingQty+t.inwardQty-t.outwardQty;const i=t.openingQty+t.inwardQty,m=t.openingValue+t.inwardValue,C=i>0?m/i:0,y=t.outwardQty*C;t.closingValue=m-y,n.total.openingQty+=t.openingQty,n.total.openingValue+=t.openingValue,n.total.inwardQty+=t.inwardQty,n.total.inwardValue+=t.inwardValue,n.total.outwardQty+=t.outwardQty,n.total.outwardValue+=t.outwardValue}),n.total.closingQty=n.total.openingQty+n.total.inwardQty-n.total.outwardQty;const o=n.total.openingQty+n.total.inwardQty,a=n.total.openingValue+n.total.inwardValue,l=o>0?a/o:0,d=n.total.outwardQty*l;n.total.closingValue=a-d}}),u},b=(I,h,E,g)=>{const f=[],u=new Date(E),p=new Date(g);p.setHours(23,59,59,999);let r=new Date(u);for(;r<=p&&(f.push({name:r.toLocaleString("default",{month:"short"}),year:r.getFullYear(),month:r.getMonth(),sales:0,profit:0}),r.setMonth(r.getMonth()+1),!(r.getFullYear()>p.getFullYear()||r.getFullYear()===p.getFullYear()&&r.getMonth()>p.getMonth())););const c=new Map(I.map(s=>[s.id,s]));return f.forEach(s=>{const e=new Date(s.year,s.month,1),n=new Date(s.year,s.month+1,0);n.setHours(23,59,59,999);const o=h.filter(d=>{const t=new Date(d.date);return t>=e&&t<=n});if(o.length===0)return;let a=0,l=0;o.forEach(d=>{d.entries.forEach(t=>{const i=c.get(t.ledgerId);if(!i)return;const m=L(i.group);m==="INCOME"?a+=t.type==="Cr"?t.amount:-t.amount:m==="EXPENSE"&&(l+=t.type==="Dr"?t.amount:-t.amount),i.group==="Sales Accounts"&&(d.type==="Sale"||d.type==="Debit Note"?s.sales+=t.type==="Cr"?t.amount:0:d.type==="Credit Note"&&(s.sales-=t.type==="Dr"?t.amount:0))})}),s.profit=a-l}),f},N=(I,h,E,g,f)=>{const u=I.filter(o=>o.group==="Sundry Debtors"),p=new Set(u.map(o=>o.id)),r=new Map(I.map(o=>[o.id,o.name])),c=new Map,s=new Date(g),e=new Date(f);return e.setHours(23,59,59,999),h.filter(o=>{const a=new Date(o.date);return o.type==="Sale"&&a>=s&&a<=e}).forEach(o=>{const a=o.entries.find(d=>p.has(d.ledgerId));if(!a)return;const l=o.entries.find(d=>{const t=I.find(i=>i.id===d.ledgerId);return(t==null?void 0:t.group)==="Sales Accounts"});if(l&&l.inventoryAllocations){const d=a.ledgerId,t=c.get(d)||{totalQuantity:0,totalValue:0};l.inventoryAllocations.forEach(i=>{t.totalQuantity+=i.quantity,t.totalValue+=i.quantity*i.rate}),c.set(d,t)}}),Array.from(c.entries()).map(([o,a])=>({customerId:o,customerName:r.get(o)||"Unknown",totalQuantity:a.totalQuantity,totalValue:a.totalValue,averagePrice:a.totalQuantity>0?a.totalValue/a.totalQuantity:0})).sort((o,a)=>a.totalValue-o.totalValue)},P=(I,h,E,g,f)=>{const u=new Map(I.map(e=>[e.id,e.name])),p=new Map,r=new Date(g),c=new Date(f);return c.setHours(23,59,59,999),h.filter(e=>{const n=new Date(e.date);return e.type==="Sale"&&e.salesmanId&&n>=r&&n<=c}).forEach(e=>{const n=e.salesmanId,o=e.entries.filter(l=>l.type==="Dr").reduce((l,d)=>l+d.amount,0),a=p.get(n)||{totalValue:0,invoiceCount:0};a.totalValue+=o,a.invoiceCount+=1,p.set(n,a)}),Array.from(p.entries()).map(([e,n])=>({salesmanId:e,salesmanName:u.get(e)||"Unknown",...n})).sort((e,n)=>n.totalValue-e.totalValue)},x=(I,h,E)=>{const g={LIABILITIES:{},ASSETS:{}};I.forEach(u=>{const p=h.get(u.id)||0;if(!(Math.abs(p)<.01&&L(u.group)!=="EQUITY"))for(const r in S)for(const c in S[r])S[r][c].includes(u.group)&&(g[r][c]||(g[r][c]=[]),g[r][c].push({name:u.name,balance:L(u.group)==="ASSET"?p:-p}))}),E!==0&&(g.LIABILITIES["Reserves & Surplus"]||(g.LIABILITIES["Reserves & Surplus"]=[]),g.LIABILITIES["Reserves & Surplus"].push({name:"Profit & Loss A/c (Period)",balance:E}));const f=(u,p)=>{var c,s;const r={id:u.toLowerCase(),title:p,total:0,children:[]};for(const e in S[u]){const n=g[u][e]||[];if(n.length>0){const o=n.reduce((a,l)=>a+l.balance,0);(c=r.children)==null||c.push({id:`${u.toLowerCase()}-${e.replace(/ /g,"-")}`,title:e,total:o,ledgers:n.map(a=>({...a,id:a.name}))})}}return r.total=((s=r.children)==null?void 0:s.reduce((e,n)=>e+n.total,0))||0,r};return[f("LIABILITIES","EQUITY AND LIABILITIES"),f("ASSETS","ASSETS")]},O=(I,h)=>{const E={INCOME:{},EXPENSE:{}};I.forEach(c=>{const s=h.get(c.id)||0;if(!(Math.abs(s)<.01)){for(const e in D)for(const n in D[e])if(D[e][n].includes(c.group)){E[e][n]||(E[e][n]=[]);const o=e==="INCOME"?-s:s;E[e][n].push({name:c.name,balance:o})}}});const g=(c,s)=>{var n,o;const e={id:c.toLowerCase(),title:s,total:0,children:[]};for(const a in D[c]){const l=E[c][a]||[];if(l.length>0){const d=l.reduce((t,i)=>t+i.balance,0);(n=e.children)==null||n.push({id:`${c.toLowerCase()}-${a.replace(/ /g,"-")}`,title:a,total:d,ledgers:l.map(t=>({...t,id:t.name}))})}}return e.total=((o=e.children)==null?void 0:o.reduce((a,l)=>a+l.total,0))||0,e},f=g("INCOME","I. Revenue"),u=g("EXPENSE","II. Expenses"),p=f.total-u.total,r={id:"profit",title:p>=0?"III. Profit for the period":"III. Loss for the period",total:p};return[f,u,r]};export{b as a,v as b,M as c,O as d,T as e,B as f,x as g,N as h,P as i};
